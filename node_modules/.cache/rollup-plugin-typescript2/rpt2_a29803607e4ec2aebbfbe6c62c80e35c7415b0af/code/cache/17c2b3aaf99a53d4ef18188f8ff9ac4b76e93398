{"code":"import { computePriceImpact, CurrencyAmount, Fraction, Price, sortedInsert, TradeType } from '@uniswap/sdk-core';\r\nimport { ONE, ZERO } from '../constants';\r\nimport invariant from 'tiny-invariant';\r\nimport { Route } from './route';\r\n// comparator function that allows sorting trades by their output amounts, in decreasing order, and then input amounts\r\n// in increasing order. i.e. the best trades have the most outputs for the least inputs and are sorted first\r\nexport function inputOutputComparator(a, b) {\r\n    // must have same input and output token for comparison\r\n    invariant(a.inputAmount.currency.equals(b.inputAmount.currency), 'INPUT_CURRENCY');\r\n    invariant(a.outputAmount.currency.equals(b.outputAmount.currency), 'OUTPUT_CURRENCY');\r\n    if (a.outputAmount.equalTo(b.outputAmount)) {\r\n        if (a.inputAmount.equalTo(b.inputAmount)) {\r\n            return 0;\r\n        }\r\n        // trade A requires less input than trade B, so A should come first\r\n        if (a.inputAmount.lessThan(b.inputAmount)) {\r\n            return -1;\r\n        }\r\n        else {\r\n            return 1;\r\n        }\r\n    }\r\n    else {\r\n        // tradeA has less output than trade B, so should come second\r\n        if (a.outputAmount.lessThan(b.outputAmount)) {\r\n            return 1;\r\n        }\r\n        else {\r\n            return -1;\r\n        }\r\n    }\r\n}\r\n// extension of the input output comparator that also considers other dimensions of the trade in ranking them\r\nexport function tradeComparator(a, b) {\r\n    const ioComp = inputOutputComparator(a, b);\r\n    if (ioComp !== 0) {\r\n        return ioComp;\r\n    }\r\n    // consider lowest slippage next, since these are less likely to fail\r\n    if (a.priceImpact.lessThan(b.priceImpact)) {\r\n        return -1;\r\n    }\r\n    else if (a.priceImpact.greaterThan(b.priceImpact)) {\r\n        return 1;\r\n    }\r\n    // finally consider the number of hops since each hop costs gas\r\n    return a.route.path.length - b.route.path.length;\r\n}\r\n/**\r\n * Represents a trade executed against a list of pairs.\r\n * Does not account for slippage, i.e. trades that front run this trade and move the price.\r\n */\r\nexport class Trade {\r\n    constructor(route, amount, tradeType) {\r\n        this.route = route;\r\n        this.tradeType = tradeType;\r\n        const tokenAmounts = new Array(route.path.length);\r\n        if (tradeType === TradeType.EXACT_INPUT) {\r\n            invariant(amount.currency.equals(route.input), 'INPUT');\r\n            tokenAmounts[0] = amount.wrapped;\r\n            for (let i = 0; i < route.path.length - 1; i++) {\r\n                const pair = route.pairs[i];\r\n                const [outputAmount] = pair.getOutputAmount(tokenAmounts[i]);\r\n                tokenAmounts[i + 1] = outputAmount;\r\n            }\r\n            this.inputAmount = CurrencyAmount.fromFractionalAmount(route.input, amount.numerator, amount.denominator);\r\n            this.outputAmount = CurrencyAmount.fromFractionalAmount(route.output, tokenAmounts[tokenAmounts.length - 1].numerator, tokenAmounts[tokenAmounts.length - 1].denominator);\r\n        }\r\n        else {\r\n            invariant(amount.currency.equals(route.output), 'OUTPUT');\r\n            tokenAmounts[tokenAmounts.length - 1] = amount.wrapped;\r\n            for (let i = route.path.length - 1; i > 0; i--) {\r\n                const pair = route.pairs[i - 1];\r\n                const [inputAmount] = pair.getInputAmount(tokenAmounts[i]);\r\n                tokenAmounts[i - 1] = inputAmount;\r\n            }\r\n            this.inputAmount = CurrencyAmount.fromFractionalAmount(route.input, tokenAmounts[0].numerator, tokenAmounts[0].denominator);\r\n            this.outputAmount = CurrencyAmount.fromFractionalAmount(route.output, amount.numerator, amount.denominator);\r\n        }\r\n        this.executionPrice = new Price(this.inputAmount.currency, this.outputAmount.currency, this.inputAmount.quotient, this.outputAmount.quotient);\r\n        this.priceImpact = computePriceImpact(route.midPrice, this.inputAmount, this.outputAmount);\r\n    }\r\n    /**\r\n     * Constructs an exact in trade with the given amount in and route\r\n     * @param route route of the exact in trade\r\n     * @param amountIn the amount being passed in\r\n     */\r\n    static exactIn(route, amountIn) {\r\n        return new Trade(route, amountIn, TradeType.EXACT_INPUT);\r\n    }\r\n    /**\r\n     * Constructs an exact out trade with the given amount out and route\r\n     * @param route route of the exact out trade\r\n     * @param amountOut the amount returned by the trade\r\n     */\r\n    static exactOut(route, amountOut) {\r\n        return new Trade(route, amountOut, TradeType.EXACT_OUTPUT);\r\n    }\r\n    /**\r\n     * Get the minimum amount that must be received from this trade for the given slippage tolerance\r\n     * @param slippageTolerance tolerance of unfavorable slippage from the execution price of this trade\r\n     */\r\n    minimumAmountOut(slippageTolerance) {\r\n        invariant(!slippageTolerance.lessThan(ZERO), 'SLIPPAGE_TOLERANCE');\r\n        if (this.tradeType === TradeType.EXACT_OUTPUT) {\r\n            return this.outputAmount;\r\n        }\r\n        else {\r\n            const slippageAdjustedAmountOut = new Fraction(ONE)\r\n                .add(slippageTolerance)\r\n                .invert()\r\n                .multiply(this.outputAmount.quotient).quotient;\r\n            return CurrencyAmount.fromRawAmount(this.outputAmount.currency, slippageAdjustedAmountOut);\r\n        }\r\n    }\r\n    /**\r\n     * Get the maximum amount in that can be spent via this trade for the given slippage tolerance\r\n     * @param slippageTolerance tolerance of unfavorable slippage from the execution price of this trade\r\n     */\r\n    maximumAmountIn(slippageTolerance) {\r\n        invariant(!slippageTolerance.lessThan(ZERO), 'SLIPPAGE_TOLERANCE');\r\n        if (this.tradeType === TradeType.EXACT_INPUT) {\r\n            return this.inputAmount;\r\n        }\r\n        else {\r\n            const slippageAdjustedAmountIn = new Fraction(ONE).add(slippageTolerance).multiply(this.inputAmount.quotient)\r\n                .quotient;\r\n            return CurrencyAmount.fromRawAmount(this.inputAmount.currency, slippageAdjustedAmountIn);\r\n        }\r\n    }\r\n    /**\r\n     * Given a list of pairs, and a fixed amount in, returns the top `maxNumResults` trades that go from an input token\r\n     * amount to an output token, making at most `maxHops` hops.\r\n     * Note this does not consider aggregation, as routes are linear. It's possible a better route exists by splitting\r\n     * the amount in among multiple routes.\r\n     * @param pairs the pairs to consider in finding the best trade\r\n     * @param nextAmountIn exact amount of input currency to spend\r\n     * @param currencyOut the desired currency out\r\n     * @param maxNumResults maximum number of results to return\r\n     * @param maxHops maximum number of hops a returned trade can make, e.g. 1 hop goes through a single pair\r\n     * @param currentPairs used in recursion; the current list of pairs\r\n     * @param currencyAmountIn used in recursion; the original value of the currencyAmountIn parameter\r\n     * @param bestTrades used in recursion; the current list of best trades\r\n     */\r\n    static bestTradeExactIn(pairs, currencyAmountIn, currencyOut, { maxNumResults = 3, maxHops = 3 } = {}, \r\n    // used in recursion.\r\n    currentPairs = [], nextAmountIn = currencyAmountIn, bestTrades = []) {\r\n        invariant(pairs.length > 0, 'PAIRS');\r\n        invariant(maxHops > 0, 'MAX_HOPS');\r\n        invariant(currencyAmountIn === nextAmountIn || currentPairs.length > 0, 'INVALID_RECURSION');\r\n        const amountIn = nextAmountIn.wrapped;\r\n        const tokenOut = currencyOut.wrapped;\r\n        for (let i = 0; i < pairs.length; i++) {\r\n            const pair = pairs[i];\r\n            // pair irrelevant\r\n            if (!pair.token0.equals(amountIn.currency) && !pair.token1.equals(amountIn.currency))\r\n                continue;\r\n            if (pair.reserve0.equalTo(ZERO) || pair.reserve1.equalTo(ZERO))\r\n                continue;\r\n            let amountOut;\r\n            try {\r\n                ;\r\n                [amountOut] = pair.getOutputAmount(amountIn);\r\n            }\r\n            catch (error) {\r\n                // input too low\r\n                if (error.isInsufficientInputAmountError) {\r\n                    continue;\r\n                }\r\n                throw error;\r\n            }\r\n            // we have arrived at the output token, so this is the final trade of one of the paths\r\n            if (amountOut.currency.equals(tokenOut)) {\r\n                sortedInsert(bestTrades, new Trade(new Route([...currentPairs, pair], currencyAmountIn.currency, currencyOut), currencyAmountIn, TradeType.EXACT_INPUT), maxNumResults, tradeComparator);\r\n            }\r\n            else if (maxHops > 1 && pairs.length > 1) {\r\n                const pairsExcludingThisPair = pairs.slice(0, i).concat(pairs.slice(i + 1, pairs.length));\r\n                // otherwise, consider all the other paths that lead from this token as long as we have not exceeded maxHops\r\n                Trade.bestTradeExactIn(pairsExcludingThisPair, currencyAmountIn, currencyOut, {\r\n                    maxNumResults,\r\n                    maxHops: maxHops - 1\r\n                }, [...currentPairs, pair], amountOut, bestTrades);\r\n            }\r\n        }\r\n        return bestTrades;\r\n    }\r\n    /**\r\n     * Return the execution price after accounting for slippage tolerance\r\n     * @param slippageTolerance the allowed tolerated slippage\r\n     */\r\n    worstExecutionPrice(slippageTolerance) {\r\n        return new Price(this.inputAmount.currency, this.outputAmount.currency, this.maximumAmountIn(slippageTolerance).quotient, this.minimumAmountOut(slippageTolerance).quotient);\r\n    }\r\n    /**\r\n     * similar to the above method but instead targets a fixed output amount\r\n     * given a list of pairs, and a fixed amount out, returns the top `maxNumResults` trades that go from an input token\r\n     * to an output token amount, making at most `maxHops` hops\r\n     * note this does not consider aggregation, as routes are linear. it's possible a better route exists by splitting\r\n     * the amount in among multiple routes.\r\n     * @param pairs the pairs to consider in finding the best trade\r\n     * @param currencyIn the currency to spend\r\n     * @param nextAmountOut the exact amount of currency out\r\n     * @param maxNumResults maximum number of results to return\r\n     * @param maxHops maximum number of hops a returned trade can make, e.g. 1 hop goes through a single pair\r\n     * @param currentPairs used in recursion; the current list of pairs\r\n     * @param currencyAmountOut used in recursion; the original value of the currencyAmountOut parameter\r\n     * @param bestTrades used in recursion; the current list of best trades\r\n     */\r\n    static bestTradeExactOut(pairs, currencyIn, currencyAmountOut, { maxNumResults = 3, maxHops = 3 } = {}, \r\n    // used in recursion.\r\n    currentPairs = [], nextAmountOut = currencyAmountOut, bestTrades = []) {\r\n        invariant(pairs.length > 0, 'PAIRS');\r\n        invariant(maxHops > 0, 'MAX_HOPS');\r\n        invariant(currencyAmountOut === nextAmountOut || currentPairs.length > 0, 'INVALID_RECURSION');\r\n        const amountOut = nextAmountOut.wrapped;\r\n        const tokenIn = currencyIn.wrapped;\r\n        for (let i = 0; i < pairs.length; i++) {\r\n            const pair = pairs[i];\r\n            // pair irrelevant\r\n            if (!pair.token0.equals(amountOut.currency) && !pair.token1.equals(amountOut.currency))\r\n                continue;\r\n            if (pair.reserve0.equalTo(ZERO) || pair.reserve1.equalTo(ZERO))\r\n                continue;\r\n            let amountIn;\r\n            try {\r\n                ;\r\n                [amountIn] = pair.getInputAmount(amountOut);\r\n            }\r\n            catch (error) {\r\n                // not enough liquidity in this pair\r\n                if (error.isInsufficientReservesError) {\r\n                    continue;\r\n                }\r\n                throw error;\r\n            }\r\n            // we have arrived at the input token, so this is the first trade of one of the paths\r\n            if (amountIn.currency.equals(tokenIn)) {\r\n                sortedInsert(bestTrades, new Trade(new Route([pair, ...currentPairs], currencyIn, currencyAmountOut.currency), currencyAmountOut, TradeType.EXACT_OUTPUT), maxNumResults, tradeComparator);\r\n            }\r\n            else if (maxHops > 1 && pairs.length > 1) {\r\n                const pairsExcludingThisPair = pairs.slice(0, i).concat(pairs.slice(i + 1, pairs.length));\r\n                // otherwise, consider all the other paths that arrive at this token as long as we have not exceeded maxHops\r\n                Trade.bestTradeExactOut(pairsExcludingThisPair, currencyIn, currencyAmountOut, {\r\n                    maxNumResults,\r\n                    maxHops: maxHops - 1\r\n                }, [pair, ...currentPairs], amountIn, bestTrades);\r\n            }\r\n        }\r\n        return bestTrades;\r\n    }\r\n}\r\n//# sourceMappingURL=trade.js.map","references":["/data0/htdocs/panfeng/uniswap-sdk/node_modules/@uniswap/sdk-core/dist/index.d.ts","/data0/htdocs/panfeng/uniswap-sdk/src/constants.ts","/data0/htdocs/panfeng/uniswap-sdk/node_modules/tiny-invariant/dist/tiny-invariant.d.ts","/data0/htdocs/panfeng/uniswap-sdk/src/entities/pair.ts","/data0/htdocs/panfeng/uniswap-sdk/src/entities/route.ts"],"map":"{\"version\":3,\"file\":\"trade.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../../../src/entities/trade.ts\"],\"names\":[],\"mappings\":\"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\"}","dts":{"name":"/data0/htdocs/panfeng/uniswap-sdk/entities/trade.d.ts","writeByteOrderMark":false,"text":"import { Currency, CurrencyAmount, Percent, Price, TradeType } from '@uniswap/sdk-core';\r\nimport { Pair } from './pair';\r\nimport { Route } from './route';\r\ninterface InputOutput<TInput extends Currency, TOutput extends Currency> {\r\n    readonly inputAmount: CurrencyAmount<TInput>;\r\n    readonly outputAmount: CurrencyAmount<TOutput>;\r\n}\r\nexport declare function inputOutputComparator<TInput extends Currency, TOutput extends Currency>(a: InputOutput<TInput, TOutput>, b: InputOutput<TInput, TOutput>): number;\r\nexport declare function tradeComparator<TInput extends Currency, TOutput extends Currency, TTradeType extends TradeType>(a: Trade<TInput, TOutput, TTradeType>, b: Trade<TInput, TOutput, TTradeType>): number;\r\nexport interface BestTradeOptions {\r\n    maxNumResults?: number;\r\n    maxHops?: number;\r\n}\r\n/**\r\n * Represents a trade executed against a list of pairs.\r\n * Does not account for slippage, i.e. trades that front run this trade and move the price.\r\n */\r\nexport declare class Trade<TInput extends Currency, TOutput extends Currency, TTradeType extends TradeType> {\r\n    /**\r\n     * The route of the trade, i.e. which pairs the trade goes through and the input/output currencies.\r\n     */\r\n    readonly route: Route<TInput, TOutput>;\r\n    /**\r\n     * The type of the trade, either exact in or exact out.\r\n     */\r\n    readonly tradeType: TTradeType;\r\n    /**\r\n     * The input amount for the trade assuming no slippage.\r\n     */\r\n    readonly inputAmount: CurrencyAmount<TInput>;\r\n    /**\r\n     * The output amount for the trade assuming no slippage.\r\n     */\r\n    readonly outputAmount: CurrencyAmount<TOutput>;\r\n    /**\r\n     * The price expressed in terms of output amount/input amount.\r\n     */\r\n    readonly executionPrice: Price<TInput, TOutput>;\r\n    /**\r\n     * The percent difference between the mid price before the trade and the trade execution price.\r\n     */\r\n    readonly priceImpact: Percent;\r\n    /**\r\n     * Constructs an exact in trade with the given amount in and route\r\n     * @param route route of the exact in trade\r\n     * @param amountIn the amount being passed in\r\n     */\r\n    static exactIn<TInput extends Currency, TOutput extends Currency>(route: Route<TInput, TOutput>, amountIn: CurrencyAmount<TInput>): Trade<TInput, TOutput, TradeType.EXACT_INPUT>;\r\n    /**\r\n     * Constructs an exact out trade with the given amount out and route\r\n     * @param route route of the exact out trade\r\n     * @param amountOut the amount returned by the trade\r\n     */\r\n    static exactOut<TInput extends Currency, TOutput extends Currency>(route: Route<TInput, TOutput>, amountOut: CurrencyAmount<TOutput>): Trade<TInput, TOutput, TradeType.EXACT_OUTPUT>;\r\n    constructor(route: Route<TInput, TOutput>, amount: TTradeType extends TradeType.EXACT_INPUT ? CurrencyAmount<TInput> : CurrencyAmount<TOutput>, tradeType: TTradeType);\r\n    /**\r\n     * Get the minimum amount that must be received from this trade for the given slippage tolerance\r\n     * @param slippageTolerance tolerance of unfavorable slippage from the execution price of this trade\r\n     */\r\n    minimumAmountOut(slippageTolerance: Percent): CurrencyAmount<TOutput>;\r\n    /**\r\n     * Get the maximum amount in that can be spent via this trade for the given slippage tolerance\r\n     * @param slippageTolerance tolerance of unfavorable slippage from the execution price of this trade\r\n     */\r\n    maximumAmountIn(slippageTolerance: Percent): CurrencyAmount<TInput>;\r\n    /**\r\n     * Given a list of pairs, and a fixed amount in, returns the top `maxNumResults` trades that go from an input token\r\n     * amount to an output token, making at most `maxHops` hops.\r\n     * Note this does not consider aggregation, as routes are linear. It's possible a better route exists by splitting\r\n     * the amount in among multiple routes.\r\n     * @param pairs the pairs to consider in finding the best trade\r\n     * @param nextAmountIn exact amount of input currency to spend\r\n     * @param currencyOut the desired currency out\r\n     * @param maxNumResults maximum number of results to return\r\n     * @param maxHops maximum number of hops a returned trade can make, e.g. 1 hop goes through a single pair\r\n     * @param currentPairs used in recursion; the current list of pairs\r\n     * @param currencyAmountIn used in recursion; the original value of the currencyAmountIn parameter\r\n     * @param bestTrades used in recursion; the current list of best trades\r\n     */\r\n    static bestTradeExactIn<TInput extends Currency, TOutput extends Currency>(pairs: Pair[], currencyAmountIn: CurrencyAmount<TInput>, currencyOut: TOutput, { maxNumResults, maxHops }?: BestTradeOptions, currentPairs?: Pair[], nextAmountIn?: CurrencyAmount<Currency>, bestTrades?: Trade<TInput, TOutput, TradeType.EXACT_INPUT>[]): Trade<TInput, TOutput, TradeType.EXACT_INPUT>[];\r\n    /**\r\n     * Return the execution price after accounting for slippage tolerance\r\n     * @param slippageTolerance the allowed tolerated slippage\r\n     */\r\n    worstExecutionPrice(slippageTolerance: Percent): Price<TInput, TOutput>;\r\n    /**\r\n     * similar to the above method but instead targets a fixed output amount\r\n     * given a list of pairs, and a fixed amount out, returns the top `maxNumResults` trades that go from an input token\r\n     * to an output token amount, making at most `maxHops` hops\r\n     * note this does not consider aggregation, as routes are linear. it's possible a better route exists by splitting\r\n     * the amount in among multiple routes.\r\n     * @param pairs the pairs to consider in finding the best trade\r\n     * @param currencyIn the currency to spend\r\n     * @param nextAmountOut the exact amount of currency out\r\n     * @param maxNumResults maximum number of results to return\r\n     * @param maxHops maximum number of hops a returned trade can make, e.g. 1 hop goes through a single pair\r\n     * @param currentPairs used in recursion; the current list of pairs\r\n     * @param currencyAmountOut used in recursion; the original value of the currencyAmountOut parameter\r\n     * @param bestTrades used in recursion; the current list of best trades\r\n     */\r\n    static bestTradeExactOut<TInput extends Currency, TOutput extends Currency>(pairs: Pair[], currencyIn: TInput, currencyAmountOut: CurrencyAmount<TOutput>, { maxNumResults, maxHops }?: BestTradeOptions, currentPairs?: Pair[], nextAmountOut?: CurrencyAmount<Currency>, bestTrades?: Trade<TInput, TOutput, TradeType.EXACT_OUTPUT>[]): Trade<TInput, TOutput, TradeType.EXACT_OUTPUT>[];\r\n}\r\nexport {};\r\n"}}
